var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var webcrypto;
(function (webcrypto) {
    function printf(text) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var msg = text;
        var regFind = /[^%](%\d+)/g;
        var match;
        var matches = [];
        while (match = regFind.exec(msg)) {
            matches.push({ arg: match[1], index: match.index });
        }
        // replace matches
        for (var i = matches.length - 1; i >= 0; i--) {
            var item = matches[i];
            var arg = item.arg.substring(1);
            var index = item.index + 1;
            msg = msg.substring(0, index) + arguments[+arg] + msg.substring(index + 1 + arg.length);
        }
        // convert %% -> %
        msg = msg.replace("%%", "%");
        return msg;
    }
    var WebCryptoError = (function (_super) {
        __extends(WebCryptoError, _super);
        function WebCryptoError(template) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            _super.call(this);
            this.code = 0;
            this.message = printf.apply(void 0, [template].concat(args));
            var error = new Error(this.message);
            error.name = this["constructor"].name;
            this.stack = error.stack;
        }
        WebCryptoError.NOT_SUPPORTED = "Method is not supported";
        return WebCryptoError;
    }(Error));
    webcrypto.WebCryptoError = WebCryptoError;
    var AlgorithmError = (function (_super) {
        __extends(AlgorithmError, _super);
        function AlgorithmError() {
            _super.apply(this, arguments);
            this.code = 1;
        }
        AlgorithmError.PARAM_REQUIRED = "Algorithm hasn't got required paramter '%1'";
        AlgorithmError.PARAM_WRONG_TYPE = "Algorithm has got wrong type for paramter '%1'. Must be %2";
        AlgorithmError.PARAM_WRONG_VALUE = "Algorithm has got wrong value for paramter '%1'. Must be %2";
        AlgorithmError.WRONG_ALG_NAME = "Algorithm has got wrong name '%1'. Must be '%2'";
        AlgorithmError.UNSUPPORTED_ALGORITHM = "Algorithm '%1' is not supported";
        return AlgorithmError;
    }(WebCryptoError));
    webcrypto.AlgorithmError = AlgorithmError;
    var CryptoKeyError = (function (_super) {
        __extends(CryptoKeyError, _super);
        function CryptoKeyError() {
            _super.apply(this, arguments);
            this.code = 3;
        }
        CryptoKeyError.EMPTY_KEY = "CryptoKey is empty";
        CryptoKeyError.WRONG_KEY_ALG = "CryptoKey has wrong algorithm '%1'. Must be '%2'";
        CryptoKeyError.WRONG_KEY_TYPE = "CryptoKey has wrong type '%1'. Must be '%2'";
        CryptoKeyError.WRONG_KEY_USAGE = "CryptoKey has wrong key usage. Must be '%1'";
        CryptoKeyError.NOT_EXTRACTABLE = "CryptoKey is not extractable";
        CryptoKeyError.WRONG_FORMAT = "CryptoKey has '%1' type. It can be used with '%2' format";
        CryptoKeyError.UNKNOWN_FORMAT = "Uknown format in use '%1'. Must be one of 'raw', 'pkcs8', 'spki'  or 'jwk'";
        CryptoKeyError.ALLOWED_FORMAT = "Wrong format value '%1'. Must be %2";
        return CryptoKeyError;
    }(WebCryptoError));
    webcrypto.CryptoKeyError = CryptoKeyError;
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    webcrypto.AlgorithmNames = {
        RsaSSA: "RSASSA-PKCS1-v1_5",
        RsaPSS: "RSA-PSS",
        RsaOAEP: "RSA-OAEP",
        AesCTR: "AES-CTR",
        AesCMAC: "AES-CMAC",
        AesGCM: "AES-GCM",
        AesCBC: "AES-CBC",
        Sha1: "SHA-1",
        Sha256: "SHA-256",
        Sha384: "SHA-384",
        Sha512: "SHA-512",
        EcDSA: "ECDSA",
        EcDH: "ECDH"
    };
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    function PrepareAlgorithm(alg) {
        var res;
        if (typeof alg === "string")
            res = { name: alg };
        else
            res = alg;
        BaseCrypto.checkAlgorithm(res);
        return res;
    }
    webcrypto.PrepareAlgorithm = PrepareAlgorithm;
    function PrepareData(data, paramName) {
        if (!data)
            throw new webcrypto.WebCryptoError("Parameter '" + paramName + "' is required and cant be empty");
        if (ArrayBuffer.isView(data) || data instanceof ArrayBuffer)
            return new Uint8Array(data);
        throw new webcrypto.WebCryptoError("Incoming parameter '" + paramName + "' has wrong data type. Must be ArrayBufferView or ArrayBuffer");
    }
    webcrypto.PrepareData = PrepareData;
    var BaseCrypto = (function () {
        function BaseCrypto() {
        }
        BaseCrypto.checkAlgorithm = function (alg) {
            if (typeof alg !== "object")
                throw new TypeError("Wrong algorithm data type. Must be Object");
            if (!("name" in alg))
                throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.PARAM_REQUIRED, "name");
            if (typeof alg.name !== "string")
                throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.PARAM_WRONG_VALUE, "name", "String");
        };
        BaseCrypto.checkAlgorithmParams = function (alg) {
            this.checkAlgorithm(alg);
        };
        BaseCrypto.checkKey = function (key, alg, type, usage) {
            if (type === void 0) { type = null; }
            if (usage === void 0) { usage = null; }
            // check key empty
            if (!key)
                throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.EMPTY_KEY);
            // check alg
            var keyAlg = key.algorithm;
            this.checkAlgorithm(keyAlg);
            if (alg && (!keyAlg || keyAlg.name.toUpperCase() !== alg.toUpperCase()))
                throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.WRONG_KEY_ALG, keyAlg.name, alg);
            // check type
            if (type && (!key.type || key.type.toUpperCase() !== type.toUpperCase()))
                throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.WRONG_KEY_TYPE, key.type, type);
            // check usage
            if (usage) {
                for (var _i = 0, _a = key.usages; _i < _a.length; _i++) {
                    var keyUsage = _a[_i];
                    if (usage.toUpperCase() === keyUsage.toUpperCase())
                        return;
                }
                throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.WRONG_KEY_USAGE, usage);
            }
        };
        BaseCrypto.checkWrappedKey = function (key) {
            if (!key.extractable)
                throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.NOT_EXTRACTABLE);
        };
        BaseCrypto.checkKeyUsages = function (keyUsages) {
            if (!keyUsages || !keyUsages.length)
                throw new webcrypto.WebCryptoError("Parameter 'keyUsages' cannot be empty.");
        };
        BaseCrypto.checkFormat = function (format, type) {
            switch (format.toLowerCase()) {
                case "raw":
                    if (type && type.toLowerCase() !== "secret")
                        throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.WRONG_FORMAT, type, "raw");
                    break;
                case "pkcs8":
                    if (type && type.toLowerCase() !== "private")
                        throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.WRONG_FORMAT, type, "pkcs8");
                    break;
                case "spki":
                    if (type && type.toLowerCase() !== "public")
                        throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.WRONG_FORMAT, type, "spki");
                    break;
                case "jwk":
                    break;
                default:
                    throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.UNKNOWN_FORMAT, format);
            }
        };
        BaseCrypto.checkFormatImport = function (format, isBuffer, type) {
            this.checkFormat(format);
            if (isBuffer) {
            }
        };
        BaseCrypto.generateKey = function (algorithm, extractable, keyUsages) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.digest = function (algorithm, data) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.sign = function (algorithm, key, data) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.verify = function (algorithm, key, signature, data) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.encrypt = function (algorithm, key, data) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.decrypt = function (algorithm, key, data) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.deriveBits = function (algorithm, baseKey, length) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.exportKey = function (format, key) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        BaseCrypto.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
            return new Promise(function (resolve, reject) {
                throw new webcrypto.WebCryptoError(webcrypto.WebCryptoError.NOT_SUPPORTED);
            });
        };
        return BaseCrypto;
    }());
    webcrypto.BaseCrypto = BaseCrypto;
})(webcrypto || (webcrypto = {}));
if (typeof module !== "undefined")
    module.exports = webcrypto;
var webcrypto;
(function (webcrypto) {
    var Base64Url = (function () {
        function Base64Url() {
        }
        Base64Url.buffer2string = function (buffer) {
            var res = "";
            for (var i = 0; i < buffer.length; i++)
                res += String.fromCharCode(buffer[i]);
            return res;
        };
        Base64Url.string2buffer = function (binaryString) {
            var res = new Uint8Array(binaryString.length);
            for (var i = 0; i < binaryString.length; i++)
                res[i] = binaryString.charCodeAt(i);
            return res;
        };
        Base64Url.encode = function (value) {
            var str = this.buffer2string(value);
            var res = btoa(str)
                .replace(/=/g, "")
                .replace(/\+/g, "-")
                .replace(/\//g, "_");
            return res;
        };
        Base64Url.decode = function (base64url) {
            while (base64url.length % 4) {
                base64url += "=";
            }
            var base64 = base64url
                .replace(/\-/g, "+")
                .replace(/_/g, "/");
            return this.string2buffer(atob(base64));
        };
        return Base64Url;
    }());
    webcrypto.Base64Url = Base64Url;
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var sha;
    (function (sha) {
        sha.ShaAlgorithms = [webcrypto.AlgorithmNames.Sha1, webcrypto.AlgorithmNames.Sha256, webcrypto.AlgorithmNames.Sha384, webcrypto.AlgorithmNames.Sha512].join(" | ");
        var Sha = (function (_super) {
            __extends(Sha, _super);
            function Sha() {
                _super.apply(this, arguments);
            }
            Sha.checkAlgorithm = function (alg) {
                var _alg;
                if (typeof alg === "string")
                    _alg = { name: alg };
                else
                    _alg = alg;
                _super.checkAlgorithm.call(this, alg);
                switch (_alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.Sha1:
                    case webcrypto.AlgorithmNames.Sha256:
                    case webcrypto.AlgorithmNames.Sha384:
                    case webcrypto.AlgorithmNames.Sha512:
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.WRONG_ALG_NAME, _alg.name, sha.ShaAlgorithms);
                }
            };
            Sha.digest = function (algorithm, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithm(algorithm);
                    resolve(undefined);
                });
            };
            return Sha;
        }(webcrypto.BaseCrypto));
        sha.Sha = Sha;
    })(sha = webcrypto.sha || (webcrypto.sha = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var rsa;
    (function (rsa) {
        var RsaKeyGenParamsError = (function (_super) {
            __extends(RsaKeyGenParamsError, _super);
            function RsaKeyGenParamsError() {
                _super.apply(this, arguments);
                this.code = 2;
            }
            return RsaKeyGenParamsError;
        }(webcrypto.AlgorithmError));
        rsa.RsaKeyGenParamsError = RsaKeyGenParamsError;
        var RsaHashedImportParamsError = (function (_super) {
            __extends(RsaHashedImportParamsError, _super);
            function RsaHashedImportParamsError() {
                _super.apply(this, arguments);
                this.code = 6;
            }
            return RsaHashedImportParamsError;
        }(webcrypto.AlgorithmError));
        rsa.RsaHashedImportParamsError = RsaHashedImportParamsError;
        var Rsa = (function (_super) {
            __extends(Rsa, _super);
            function Rsa() {
                _super.apply(this, arguments);
            }
            Rsa.checkAlgorithm = function (alg) {
                if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase())
                    throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);
            };
            Rsa.checkImportAlgorithm = function (alg) {
                /**
                 * Check alg name. Use the same way as Chrome uses.
                 * It throws error if algorithm doesn't have a `name` paramter
                 * But it's not a equal to W3 specification
                 * https://www.w3.org/TR/WebCryptoAPI/#dfn-RsaHashedImportParams
                 *
                 */
                this.checkAlgorithm(alg);
                if (!alg.hash)
                    throw new RsaHashedImportParamsError(RsaHashedImportParamsError.PARAM_REQUIRED, "hash");
                webcrypto.sha.Sha.checkAlgorithm(alg.hash);
            };
            Rsa.checkKeyGenParams = function (alg) {
                // modulusLength
                switch (alg.modulusLength) {
                    case 1024:
                    case 2048:
                    case 4096:
                        break;
                    default:
                        throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_VALUE, "modulusLength", "1024, 2048 or 4096");
                }
                // publicExponent
                var pubExp = alg.publicExponent;
                if (!pubExp)
                    throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_REQUIRED, "publicExponent");
                if (!ArrayBuffer.isView(pubExp))
                    throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_TYPE, "publicExponent", "ArrayBufferView");
                if (!(pubExp[0] === 3 || (pubExp[0] === 1 && pubExp[1] === 0 && pubExp[2] === 1)))
                    throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_VALUE, "publicExponent", "Uint8Array([3]) | Uint8Array([1, 0, 1])");
                // hash
                if (!alg.hash)
                    throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_REQUIRED, "hash", webcrypto.sha.ShaAlgorithms);
                webcrypto.sha.Sha.checkAlgorithm(alg.hash);
            };
            Rsa.checkKeyGenUsages = function (keyUsages) {
                this.checkKeyUsages(keyUsages);
                for (var _i = 0, keyUsages_1 = keyUsages; _i < keyUsages_1.length; _i++) {
                    var usage = keyUsages_1[_i];
                    var i = 0;
                    for (i; i < this.KEY_USAGES.length; i++)
                        if (this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {
                            break;
                        }
                    if (i === this.KEY_USAGES.length)
                        throw new webcrypto.WebCryptoError("Unsuported key usage '" + usage + "'. Should be one of [" + this.KEY_USAGES.join(", ") + "]");
                }
            };
            Rsa.generateKey = function (algorithm, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithm(algorithm);
                    _this.checkKeyGenParams(algorithm);
                    _this.checkKeyGenUsages(keyUsages);
                    resolve(undefined);
                });
            };
            Rsa.exportKey = function (format, key) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkKey(key, _this.ALG_NAME);
                    _this.checkFormat(format, key.type);
                    resolve(undefined);
                });
            };
            Rsa.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkImportAlgorithm(algorithm);
                    _this.checkFormat(format);
                    if (format.toLowerCase() === "raw")
                        throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.ALLOWED_FORMAT, format, "'JsonWebKey', 'pkcs8' or 'spki'");
                    _this.checkKeyGenUsages(keyUsages);
                    resolve(undefined);
                });
            };
            Rsa.ALG_NAME = "";
            Rsa.KEY_USAGES = [];
            return Rsa;
        }(webcrypto.BaseCrypto));
        rsa.Rsa = Rsa;
        var RsaSSA = (function (_super) {
            __extends(RsaSSA, _super);
            function RsaSSA() {
                _super.apply(this, arguments);
            }
            RsaSSA.sign = function (algorithm, key, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(algorithm);
                    _this.checkKey(key, _this.ALG_NAME, "private", "sign");
                    resolve(undefined);
                });
            };
            RsaSSA.verify = function (algorithm, key, signature, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(algorithm);
                    _this.checkKey(key, _this.ALG_NAME, "public", "verify");
                    resolve(undefined);
                });
            };
            RsaSSA.ALG_NAME = webcrypto.AlgorithmNames.RsaSSA;
            RsaSSA.KEY_USAGES = ["sign", "verify"];
            return RsaSSA;
        }(Rsa));
        rsa.RsaSSA = RsaSSA;
        var RsaPSSParamsError = (function (_super) {
            __extends(RsaPSSParamsError, _super);
            function RsaPSSParamsError() {
                _super.apply(this, arguments);
                this.code = 4;
            }
            return RsaPSSParamsError;
        }(webcrypto.AlgorithmError));
        rsa.RsaPSSParamsError = RsaPSSParamsError;
        var RsaPSS = (function (_super) {
            __extends(RsaPSS, _super);
            function RsaPSS() {
                _super.apply(this, arguments);
            }
            RsaPSS.checkRsaPssParams = function (alg) {
                /**
                 * TODO: Check alg verification in browser
                 */
                _super.checkAlgorithmParams.call(this, alg);
                if (!alg.saltLength)
                    return new RsaPSSParamsError(RsaPSSParamsError.PARAM_REQUIRED, "saltLength");
                if (alg.saltLength % 8)
                    return new RsaPSSParamsError("Parameter 'saltLength' should be a multiple of 8");
            };
            RsaPSS.ALG_NAME = webcrypto.AlgorithmNames.RsaPSS;
            RsaPSS.KEY_USAGES = ["sign", "verify"];
            return RsaPSS;
        }(RsaSSA));
        rsa.RsaPSS = RsaPSS;
        var RsaOAEPParamsError = (function (_super) {
            __extends(RsaOAEPParamsError, _super);
            function RsaOAEPParamsError() {
                _super.apply(this, arguments);
                this.code = 5;
            }
            return RsaOAEPParamsError;
        }(webcrypto.AlgorithmError));
        rsa.RsaOAEPParamsError = RsaOAEPParamsError;
        var RsaOAEP = (function (_super) {
            __extends(RsaOAEP, _super);
            function RsaOAEP() {
                _super.apply(this, arguments);
            }
            RsaOAEP.checkAlgorithmParams = function (alg) {
                if (alg.label) {
                    if (!ArrayBuffer.isView(alg.label))
                        return new RsaOAEPParamsError(RsaOAEPParamsError.PARAM_WRONG_TYPE, "label", "ArrayBufferView");
                }
            };
            RsaOAEP.encrypt = function (algorithm, key, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(algorithm);
                    _this.checkKey(key, _this.ALG_NAME, "public", "encrypt");
                    resolve(undefined);
                });
            };
            RsaOAEP.decrypt = function (algorithm, key, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(algorithm);
                    _this.checkKey(key, _this.ALG_NAME, "private", "decrypt");
                    resolve(undefined);
                });
            };
            RsaOAEP.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(wrapAlgorithm);
                    _this.checkKey(wrappingKey, _this.ALG_NAME, "public", "wrapKey");
                    _this.checkWrappedKey(key);
                    _this.checkFormat(format, key.type);
                    resolve(undefined);
                });
            };
            RsaOAEP.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(unwrapAlgorithm);
                    _this.checkKey(unwrappingKey, _this.ALG_NAME, "private", "unwrapKey");
                    _this.checkFormat(format);
                    // TODO check unwrappedKeyAlgorithm
                    // TODO check keyUSages
                    resolve(undefined);
                });
            };
            RsaOAEP.ALG_NAME = webcrypto.AlgorithmNames.RsaOAEP;
            RsaOAEP.KEY_USAGES = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
            return RsaOAEP;
        }(Rsa));
        rsa.RsaOAEP = RsaOAEP;
    })(rsa = webcrypto.rsa || (webcrypto.rsa = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var aes;
    (function (aes) {
        var AesKeyGenParamsError = (function (_super) {
            __extends(AesKeyGenParamsError, _super);
            function AesKeyGenParamsError() {
                _super.apply(this, arguments);
                this.code = 7;
            }
            return AesKeyGenParamsError;
        }(webcrypto.AlgorithmError));
        var Aes = (function (_super) {
            __extends(Aes, _super);
            function Aes() {
                _super.apply(this, arguments);
            }
            Aes.checkAlgorithm = function (alg) {
                if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase())
                    throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);
            };
            Aes.checkKeyGenParams = function (alg) {
                switch (alg.length) {
                    case 128:
                    case 192:
                    case 256:
                        break;
                    default:
                        throw new AesKeyGenParamsError(AesKeyGenParamsError.PARAM_WRONG_VALUE, "length", "128, 192 or 256");
                }
            };
            Aes.checkKeyGenUsages = function (keyUsages) {
                this.checkKeyUsages(keyUsages);
                for (var _i = 0, keyUsages_2 = keyUsages; _i < keyUsages_2.length; _i++) {
                    var usage = keyUsages_2[_i];
                    var i = 0;
                    for (i; i < this.KEY_USAGES.length; i++)
                        if (this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {
                            break;
                        }
                    if (i === this.KEY_USAGES.length)
                        throw new webcrypto.WebCryptoError("Unsuported key usage '" + usage + "'. Should be one of [" + this.KEY_USAGES.join(", ") + "]");
                }
            };
            Aes.generateKey = function (algorithm, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithm(algorithm);
                    _this.checkKeyGenParams(algorithm);
                    _this.checkKeyGenUsages(keyUsages);
                    resolve(undefined);
                });
            };
            Aes.exportKey = function (format, key) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkKey(key, _this.ALG_NAME);
                    _this.checkFormat(format, key.type);
                    resolve(undefined);
                });
            };
            Aes.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithm(algorithm);
                    _this.checkFormat(format);
                    if (!(format.toLowerCase() === "raw" || format.toLowerCase() === "jwk"))
                        throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.ALLOWED_FORMAT, format, "'jwk' or 'raw'");
                    _this.checkKeyGenUsages(keyUsages);
                    resolve(undefined);
                });
            };
            Aes.ALG_NAME = "";
            Aes.KEY_USAGES = [];
            return Aes;
        }(webcrypto.BaseCrypto));
        aes.Aes = Aes;
        var AesAlgorithmError = (function (_super) {
            __extends(AesAlgorithmError, _super);
            function AesAlgorithmError() {
                _super.apply(this, arguments);
                this.code = 8;
            }
            return AesAlgorithmError;
        }(webcrypto.AlgorithmError));
        aes.AesAlgorithmError = AesAlgorithmError;
        var AesEncrypt = (function (_super) {
            __extends(AesEncrypt, _super);
            function AesEncrypt() {
                _super.apply(this, arguments);
            }
            AesEncrypt.encrypt = function (algorithm, key, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(algorithm);
                    _this.checkKey(key, _this.ALG_NAME, "secret", "encrypt");
                    resolve(undefined);
                });
            };
            AesEncrypt.decrypt = function (algorithm, key, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(algorithm);
                    _this.checkKey(key, _this.ALG_NAME, "secret", "decrypt");
                    resolve(undefined);
                });
            };
            AesEncrypt.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(wrapAlgorithm);
                    _this.checkKey(wrappingKey, _this.ALG_NAME, "secret", "wrapKey");
                    _this.checkWrappedKey(key);
                    _this.checkFormat(format, key.type);
                    resolve(undefined);
                });
            };
            AesEncrypt.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(unwrapAlgorithm);
                    _this.checkKey(unwrappingKey, _this.ALG_NAME, "secret", "unwrapKey");
                    _this.checkFormat(format);
                    // TODO check unwrappedKeyAlgorithm
                    // TODO check keyUSages
                    resolve(undefined);
                });
            };
            AesEncrypt.KEY_USAGES = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
            return AesEncrypt;
        }(Aes));
        aes.AesEncrypt = AesEncrypt;
        var AesCBC = (function (_super) {
            __extends(AesCBC, _super);
            function AesCBC() {
                _super.apply(this, arguments);
            }
            AesCBC.checkAlgorithmParams = function (alg) {
                this.checkAlgorithm(alg);
                if (!alg.iv)
                    throw new AesAlgorithmError(AesAlgorithmError.PARAM_REQUIRED, "iv");
                if (!ArrayBuffer.isView(alg.iv))
                    throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_TYPE, "iv", "ArrayBufferView");
                if (alg.iv.byteLength !== 16)
                    throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_VALUE, "iv", "ArrayBufferView with size 16");
            };
            AesCBC.ALG_NAME = webcrypto.AlgorithmNames.AesCBC;
            return AesCBC;
        }(AesEncrypt));
        aes.AesCBC = AesCBC;
        var AesCTR = (function (_super) {
            __extends(AesCTR, _super);
            function AesCTR() {
                _super.apply(this, arguments);
            }
            AesCTR.checkAlgorithmParams = function (alg) {
                this.checkAlgorithm(alg);
                if (!(alg.counter && ArrayBuffer.isView(alg.counter)))
                    throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_TYPE, "counter", "ArrayBufferView");
                if (alg.counter.byteLength !== 16)
                    throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_VALUE, "counter", "ArrayBufferView with size 16");
                if (!(alg.length > 0 && alg.length <= 128))
                    throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_VALUE, "length", "number [1-128]");
            };
            AesCTR.ALG_NAME = webcrypto.AlgorithmNames.AesCTR;
            return AesCTR;
        }(AesEncrypt));
        aes.AesCTR = AesCTR;
        var AesGCM = (function (_super) {
            __extends(AesGCM, _super);
            function AesGCM() {
                _super.apply(this, arguments);
            }
            AesGCM.checkAlgorithmParams = function (alg) {
                this.checkAlgorithm(alg);
                if (alg.additionalData)
                    if (!ArrayBuffer.isView(alg.additionalData))
                        throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_TYPE, "additionalData", "ArrayBufferView");
                if (!alg.iv)
                    throw new AesAlgorithmError(AesAlgorithmError.PARAM_REQUIRED, "iv");
                if (!ArrayBuffer.isView(alg.iv))
                    throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_TYPE, "iv", "ArrayBufferView");
                if (alg.tagLength)
                    if (!(alg.tagLength >= 0 && alg.tagLength <= 128))
                        throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_VALUE, "tagLength", "number [0-128]");
            };
            AesGCM.ALG_NAME = webcrypto.AlgorithmNames.AesGCM;
            return AesGCM;
        }(AesEncrypt));
        aes.AesGCM = AesGCM;
    })(aes = webcrypto.aes || (webcrypto.aes = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var ec;
    (function (ec) {
        var AesCBC = webcrypto.aes.AesCBC, AesCTR = webcrypto.aes.AesCTR, AesGCM = webcrypto.aes.AesGCM;
        var Sha = webcrypto.sha.Sha;
        var EcKeyGenParamsError = (function (_super) {
            __extends(EcKeyGenParamsError, _super);
            function EcKeyGenParamsError() {
                _super.apply(this, arguments);
                this.code = 9;
            }
            return EcKeyGenParamsError;
        }(webcrypto.AlgorithmError));
        ec.EcKeyGenParamsError = EcKeyGenParamsError;
        var Ec = (function (_super) {
            __extends(Ec, _super);
            function Ec() {
                _super.apply(this, arguments);
            }
            Ec.checkAlgorithm = function (alg) {
                if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase())
                    throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);
            };
            Ec.checkKeyGenParams = function (alg) {
                var param_namedCurve = "namedCurve";
                if (!alg.namedCurve)
                    throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_REQUIRED, param_namedCurve);
                if (!(typeof alg.namedCurve === "string"))
                    throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_WRONG_TYPE, param_namedCurve, "string");
                switch (alg.namedCurve.toUpperCase()) {
                    case "P-256":
                    case "P-384":
                    case "P-521":
                        break;
                    default:
                        throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_WRONG_VALUE, param_namedCurve, "P-256, P-384 or P-521");
                }
            };
            Ec.checkKeyGenUsages = function (keyUsages) {
                // this.checkKeyUsages(keyUsages);
                for (var _i = 0, keyUsages_3 = keyUsages; _i < keyUsages_3.length; _i++) {
                    var usage = keyUsages_3[_i];
                    var i = 0;
                    for (i; i < this.KEY_USAGES.length; i++)
                        if (this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {
                            break;
                        }
                    if (i === this.KEY_USAGES.length)
                        throw new webcrypto.WebCryptoError("Unsuported key usage '" + usage + "'. Should be one of [" + this.KEY_USAGES.join(", ") + "]");
                }
            };
            Ec.generateKey = function (algorithm, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithm(algorithm);
                    _this.checkKeyGenParams(algorithm);
                    _this.checkKeyGenUsages(keyUsages);
                    resolve(undefined);
                });
            };
            Ec.exportKey = function (format, key) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkKey(key, _this.ALG_NAME);
                    _this.checkFormat(format, key.type);
                    resolve(undefined);
                });
            };
            Ec.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkKeyGenParams(algorithm);
                    _this.checkFormat(format);
                    if (format.toLowerCase() === "raw")
                        throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.ALLOWED_FORMAT, format, "'JsonWebKey', 'pkcs8' or 'spki'");
                    _this.checkKeyGenUsages(keyUsages);
                    resolve(undefined);
                });
            };
            Ec.ALG_NAME = "";
            Ec.KEY_USAGES = [];
            return Ec;
        }(webcrypto.BaseCrypto));
        ec.Ec = Ec;
        var EcAlgorithmError = (function (_super) {
            __extends(EcAlgorithmError, _super);
            function EcAlgorithmError() {
                _super.apply(this, arguments);
                this.code = 10;
            }
            return EcAlgorithmError;
        }(webcrypto.AlgorithmError));
        ec.EcAlgorithmError = EcAlgorithmError;
        var EcDSA = (function (_super) {
            __extends(EcDSA, _super);
            function EcDSA() {
                _super.apply(this, arguments);
            }
            EcDSA.checkAlgorithmParams = function (alg) {
                this.checkAlgorithm(alg);
                Sha.checkAlgorithm(alg.hash);
            };
            EcDSA.sign = function (algorithm, key, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(algorithm);
                    _this.checkKey(key, _this.ALG_NAME, "private", "sign");
                    resolve(undefined);
                });
            };
            EcDSA.verify = function (algorithm, key, signature, data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkAlgorithmParams(algorithm);
                    _this.checkKey(key, _this.ALG_NAME, "public", "verify");
                    resolve(undefined);
                });
            };
            EcDSA.ALG_NAME = webcrypto.AlgorithmNames.EcDSA;
            EcDSA.KEY_USAGES = ["sign", "verify", "deriveKey", "deriveBits"];
            return EcDSA;
        }(Ec));
        ec.EcDSA = EcDSA;
        var EcDH = (function (_super) {
            __extends(EcDH, _super);
            function EcDH() {
                _super.apply(this, arguments);
            }
            EcDH.checkDeriveParams = function (algorithm) {
                var param_public = "public";
                this.checkAlgorithm(algorithm);
                if (!algorithm.public)
                    throw new EcAlgorithmError(EcAlgorithmError.PARAM_REQUIRED, param_public);
                this.checkKey(algorithm.public, this.ALG_NAME, "public");
            };
            EcDH.deriveBits = function (algorithm, baseKey, length) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkDeriveParams(algorithm);
                    _this.checkKey(baseKey, _this.ALG_NAME, "private", "deriveBits");
                    resolve(undefined);
                });
            };
            EcDH.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.checkDeriveParams(algorithm);
                    _this.checkKey(baseKey, _this.ALG_NAME, "private", "deriveKey");
                    webcrypto.BaseCrypto.checkAlgorithm(derivedKeyType);
                    switch (derivedKeyType.name.toUpperCase()) {
                        case webcrypto.AlgorithmNames.AesCBC:
                            AesCBC.checkKeyGenParams(derivedKeyType);
                            break;
                        case webcrypto.AlgorithmNames.AesCTR:
                            AesCTR.checkKeyGenParams(derivedKeyType);
                            break;
                        case webcrypto.AlgorithmNames.AesGCM:
                            AesGCM.checkKeyGenParams(derivedKeyType);
                            break;
                        default:
                            throw new EcAlgorithmError("Unsupported name '" + derivedKeyType.name + "' for algoritm in param 'derivedKeyType'");
                    }
                    resolve(undefined);
                });
            };
            EcDH.ALG_NAME = webcrypto.AlgorithmNames.EcDH;
            EcDH.KEY_USAGES = ["deriveKey", "deriveBits"];
            return EcDH;
        }(Ec));
        ec.EcDH = EcDH;
    })(ec = webcrypto.ec || (webcrypto.ec = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var Sha = webcrypto.sha.Sha;
    var RsaOAEP = webcrypto.rsa.RsaOAEP, RsaPSS = webcrypto.rsa.RsaPSS, RsaSSA = webcrypto.rsa.RsaSSA;
    var AesCBC = webcrypto.aes.AesCBC, AesCTR = webcrypto.aes.AesCTR, AesGCM = webcrypto.aes.AesGCM;
    var EcDH = webcrypto.ec.EcDH, EcDSA = webcrypto.ec.EcDSA;
    var SubtleCrypto = (function () {
        function SubtleCrypto() {
        }
        SubtleCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaSSA.toUpperCase():
                        Class = RsaSSA;
                        break;
                    case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                        Class = RsaOAEP;
                        break;
                    case webcrypto.AlgorithmNames.RsaPSS.toUpperCase():
                        Class = RsaPSS;
                        break;
                    case webcrypto.AlgorithmNames.AesCBC.toUpperCase():
                        Class = AesCBC;
                        break;
                    case webcrypto.AlgorithmNames.AesCTR.toUpperCase():
                        Class = AesCTR;
                        break;
                    case webcrypto.AlgorithmNames.AesGCM.toUpperCase():
                        Class = AesGCM;
                        break;
                    case webcrypto.AlgorithmNames.EcDSA.toUpperCase():
                        Class = EcDSA;
                        break;
                    case webcrypto.AlgorithmNames.EcDH.toUpperCase():
                        Class = EcDH;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.generateKey(alg, extractable, keyUsages).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.digest = function (algorithm, data) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var buf = webcrypto.PrepareData(data, "data");
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.Sha1.toUpperCase():
                    case webcrypto.AlgorithmNames.Sha256.toUpperCase():
                    case webcrypto.AlgorithmNames.Sha384.toUpperCase():
                    case webcrypto.AlgorithmNames.Sha512.toUpperCase():
                        Class = Sha;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.digest(alg, buf).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.sign = function (algorithm, key, data) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var buf = webcrypto.PrepareData(data, "data");
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaSSA.toUpperCase():
                        Class = RsaSSA;
                        break;
                    case webcrypto.AlgorithmNames.RsaPSS.toUpperCase():
                        Class = RsaPSS;
                        break;
                    case webcrypto.AlgorithmNames.EcDSA.toUpperCase():
                        Class = EcDSA;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.sign(alg, key, buf).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.verify = function (algorithm, key, signature, data) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var sigBuf = webcrypto.PrepareData(data, "signature");
                var buf = webcrypto.PrepareData(data, "data");
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaSSA.toUpperCase():
                        Class = RsaSSA;
                        break;
                    case webcrypto.AlgorithmNames.RsaPSS.toUpperCase():
                        Class = RsaPSS;
                        break;
                    case webcrypto.AlgorithmNames.EcDSA.toUpperCase():
                        Class = EcDSA;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.verify(alg, key, sigBuf, buf).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.encrypt = function (algorithm, key, data) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var buf = webcrypto.PrepareData(data, "data");
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                        Class = RsaOAEP;
                        break;
                    case webcrypto.AlgorithmNames.AesCBC.toUpperCase():
                        Class = AesCBC;
                        break;
                    case webcrypto.AlgorithmNames.AesCTR.toUpperCase():
                        Class = AesCTR;
                        break;
                    case webcrypto.AlgorithmNames.AesGCM.toUpperCase():
                        Class = AesGCM;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.encrypt(alg, key, buf).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.decrypt = function (algorithm, key, data) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var buf = webcrypto.PrepareData(data, "data");
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                        Class = RsaOAEP;
                        break;
                    case webcrypto.AlgorithmNames.AesCBC.toUpperCase():
                        Class = AesCBC;
                        break;
                    case webcrypto.AlgorithmNames.AesCTR.toUpperCase():
                        Class = AesCTR;
                        break;
                    case webcrypto.AlgorithmNames.AesGCM.toUpperCase():
                        Class = AesGCM;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.decrypt(alg, key, buf).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.deriveBits = function (algorithm, baseKey, length) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.EcDH.toUpperCase():
                        Class = EcDH;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.deriveBits(alg, baseKey, length).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var derivedAlg = webcrypto.PrepareAlgorithm(derivedKeyType);
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.EcDH.toUpperCase():
                        Class = EcDH;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.deriveKey(alg, baseKey, derivedAlg, extractable, keyUsages).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.exportKey = function (format, key) {
            return new Promise(function (resolve, reject) {
                webcrypto.BaseCrypto.checkKey(key);
                if (!key.extractable)
                    throw new webcrypto.CryptoKeyError(webcrypto.CryptoKeyError.NOT_EXTRACTABLE);
                var Class = webcrypto.BaseCrypto;
                switch (key.algorithm.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaSSA.toUpperCase():
                        Class = RsaSSA;
                        break;
                    case webcrypto.AlgorithmNames.RsaPSS.toUpperCase():
                        Class = RsaPSS;
                        break;
                    case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                        Class = RsaOAEP;
                        break;
                    case webcrypto.AlgorithmNames.AesCBC.toUpperCase():
                        Class = AesCBC;
                        break;
                    case webcrypto.AlgorithmNames.AesCTR.toUpperCase():
                        Class = AesCTR;
                        break;
                    case webcrypto.AlgorithmNames.AesGCM.toUpperCase():
                        Class = AesGCM;
                        break;
                    case webcrypto.AlgorithmNames.EcDSA.toUpperCase():
                        Class = EcDSA;
                        break;
                    case webcrypto.AlgorithmNames.EcDH.toUpperCase():
                        Class = EcDH;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, key.algorithm.name);
                }
                Class.exportKey(format, key).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(algorithm);
                var Class = webcrypto.BaseCrypto;
                // TODO prepare keyData
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaSSA.toUpperCase():
                        Class = RsaSSA;
                        break;
                    case webcrypto.AlgorithmNames.RsaPSS.toUpperCase():
                        Class = RsaPSS;
                        break;
                    case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                        Class = RsaOAEP;
                        break;
                    case webcrypto.AlgorithmNames.AesCBC.toUpperCase():
                        Class = AesCBC;
                        break;
                    case webcrypto.AlgorithmNames.AesCTR.toUpperCase():
                        Class = AesCTR;
                        break;
                    case webcrypto.AlgorithmNames.AesGCM.toUpperCase():
                        Class = AesGCM;
                        break;
                    case webcrypto.AlgorithmNames.EcDSA.toUpperCase():
                        Class = EcDSA;
                        break;
                    case webcrypto.AlgorithmNames.EcDH.toUpperCase():
                        Class = EcDH;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.importKey(format, keyData, alg, extractable, keyUsages).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
            return new Promise(function (resolve, reject) {
                var alg = webcrypto.PrepareAlgorithm(wrapAlgorithm);
                var Class = webcrypto.BaseCrypto;
                switch (alg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                        Class = RsaOAEP;
                        break;
                    case webcrypto.AlgorithmNames.AesCBC.toUpperCase():
                        Class = AesCBC;
                        break;
                    case webcrypto.AlgorithmNames.AesCTR.toUpperCase():
                        Class = AesCTR;
                        break;
                    case webcrypto.AlgorithmNames.AesGCM.toUpperCase():
                        Class = AesGCM;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
                }
                Class.wrapKey(format, key, wrappingKey, alg).then(resolve, reject);
            });
        };
        SubtleCrypto.prototype.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
            return new Promise(function (resolve, reject) {
                var unwrapAlg = webcrypto.PrepareAlgorithm(unwrapAlgorithm);
                var unwrappedAlg = webcrypto.PrepareAlgorithm(unwrappedKeyAlgorithm);
                var buf = webcrypto.PrepareData(wrappedKey, "wrappedKey");
                var Class = webcrypto.BaseCrypto;
                switch (unwrapAlg.name.toUpperCase()) {
                    case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                        Class = RsaOAEP;
                        break;
                    case webcrypto.AlgorithmNames.AesCBC.toUpperCase():
                        Class = AesCBC;
                        break;
                    case webcrypto.AlgorithmNames.AesCTR.toUpperCase():
                        Class = AesCTR;
                        break;
                    case webcrypto.AlgorithmNames.AesGCM.toUpperCase():
                        Class = AesGCM;
                        break;
                    default:
                        throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, unwrapAlg.name);
                }
                Class.unwrapKey(format, buf, unwrappingKey, unwrapAlg, unwrappedAlg, extractable, keyUsages).then(resolve, reject);
            });
        };
        return SubtleCrypto;
    }());
    webcrypto.SubtleCrypto = SubtleCrypto;
})(webcrypto || (webcrypto = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        var _w = window;
        liner.nativeCrypto = _w.msCrypto || _w.crypto;
        liner.nativeSubtle = liner.nativeCrypto.subtle || liner.nativeCrypto.webkitSubtle;
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        liner.Browser = {
            IE: "Internet Explorer",
            Safari: "Safari",
            Edge: "Edge",
            Chrome: "Chrome",
            Firefox: "Firefox Mozilla"
        };
        /**
         * Returns info about browser
         */
        function BrowserInfo() {
            var res = {
                name: "",
                version: ""
            };
            var userAgent = window.navigator.userAgent;
            var reg;
            if (reg = /edge\/([\d\.]+)/i.exec(userAgent)) {
                res.name = liner.Browser.Edge;
                res.version = reg[1];
            }
            else if (/msie/i.test(userAgent)) {
                res.name = liner.Browser.IE;
                res.version = /msie ([\d\.]+)/i.exec(userAgent)[1];
            }
            else if (/chrome/i.test(userAgent)) {
                res.name = liner.Browser.Chrome;
                res.version = /chrome\/([\d\.]+)/i.exec(userAgent)[1];
            }
            else if (/safari/i.test(userAgent)) {
                res.name = liner.Browser.Safari;
                res.version = /([\d\.]+) safari/i.exec(userAgent)[1];
            }
            else if (/firefox/i.test(userAgent)) {
                res.name = liner.Browser.Firefox;
                res.version = /firefox\/([\d\.]+)/i.exec(userAgent)[1];
            }
            return res;
        }
        liner.BrowserInfo = BrowserInfo;
        function string2buffer(binaryString) {
            var res = new Uint8Array(binaryString.length);
            for (var i = 0; i < binaryString.length; i++)
                res[i] = binaryString.charCodeAt(i);
            return res;
        }
        liner.string2buffer = string2buffer;
        function buffer2string(buffer) {
            var res = "";
            for (var i = 0; i < buffer.length; i++)
                res += String.fromCharCode(buffer[i]);
            return res;
        }
        liner.buffer2string = buffer2string;
        function concat() {
            var buf = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                buf[_i - 0] = arguments[_i];
            }
            var res = new Uint8Array(buf.map(function (item) { return item.length; }).reduce(function (prev, cur) { return prev + cur; }));
            var offset = 0;
            buf.forEach(function (item, index) {
                for (var i = 0; i < item.length; i++)
                    res[offset + i] = item[i];
                offset += item.length;
            });
            return res;
        }
        liner.concat = concat;
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        var CryptoKey = (function () {
            function CryptoKey() {
            }
            return CryptoKey;
        }());
        liner.CryptoKey = CryptoKey;
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        var sha;
        (function (sha) {
            var ShaCrypto = (function (_super) {
                __extends(ShaCrypto, _super);
                function ShaCrypto() {
                    _super.apply(this, arguments);
                }
                ShaCrypto.digest = function (alg, message) {
                    return new Promise(function (resolve) {
                        if (typeof asmCrypto === "undefined")
                            throw new liner.LinerError(liner.LinerError.MODULE_NOT_FOUND, "asmCrypto", "https://github.com/vibornoff/asmcrypto.js");
                        switch (alg.name.toUpperCase()) {
                            case webcrypto.AlgorithmNames.Sha1:
                                resolve(asmCrypto.SHA1.bytes(message).buffer);
                                break;
                            case webcrypto.AlgorithmNames.Sha256:
                                resolve(asmCrypto.SHA256.bytes(message).buffer);
                                break;
                            default:
                                throw new liner.LinerError("Not supported algorithm '" + alg.name + "'");
                        }
                    });
                };
                return ShaCrypto;
            }(webcrypto.BaseCrypto));
            sha.ShaCrypto = ShaCrypto;
        })(sha = liner.sha || (liner.sha = {}));
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        var aes;
        (function (aes) {
            var AesCrypto = (function (_super) {
                __extends(AesCrypto, _super);
                function AesCrypto() {
                    _super.apply(this, arguments);
                }
                AesCrypto.checkModule = function () {
                    if (typeof asmCrypto === "undefined")
                        throw new liner.LinerError(liner.LinerError.MODULE_NOT_FOUND, "asmCrypto", "https://github.com/vibornoff/asmcrypto.js");
                };
                AesCrypto.generateKey = function (alg, extractable, keyUsage) {
                    var _this = this;
                    return new Promise(function (resolve) {
                        _this.checkModule();
                        // gat random bytes for key
                        var key = liner.nativeCrypto.getRandomValues(new Uint8Array(alg.length / 8));
                        // set key params
                        var aesKey = new liner.CryptoKey();
                        aesKey.key = key;
                        aesKey.algorithm = alg;
                        aesKey.extractable = extractable;
                        aesKey.type = "secret";
                        aesKey.usages = keyUsage;
                        resolve(aesKey);
                    });
                };
                AesCrypto.encrypt = function (algorithm, key, data) {
                    return new Promise(function (resolve) {
                        var res;
                        switch (algorithm.name.toUpperCase()) {
                            case webcrypto.AlgorithmNames.AesCBC:
                                var algCBC = algorithm;
                                res = asmCrypto.AES_CBC.encrypt(data, key.key, undefined, algCBC.iv);
                                break;
                            case webcrypto.AlgorithmNames.AesGCM:
                                var algGCM = algorithm;
                                res = asmCrypto.AES_GCM.encrypt(data, key.key, algGCM.iv, algGCM.additionalData, algGCM.tagLength / 8);
                                break;
                            default:
                                throw new liner.LinerError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, algorithm.name);
                        }
                        resolve(res.buffer);
                    });
                };
                AesCrypto.decrypt = function (algorithm, key, data) {
                    return new Promise(function (resolve) {
                        var res;
                        switch (algorithm.name.toUpperCase()) {
                            case webcrypto.AlgorithmNames.AesCBC:
                                var algCBC = algorithm;
                                res = asmCrypto.AES_CBC.decrypt(data, key.key, undefined, algCBC.iv);
                                break;
                            case webcrypto.AlgorithmNames.AesGCM:
                                var algGCM = algorithm;
                                res = asmCrypto.AES_GCM.decrypt(data, key.key, algGCM.iv, algGCM.additionalData, algGCM.tagLength / 8);
                                break;
                            default:
                                throw new liner.LinerError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, algorithm.name);
                        }
                        resolve(res.buffer);
                    });
                };
                AesCrypto.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
                    return new Promise(function (resolve, reject) {
                        window.crypto.subtle.exportKey(format, key)
                            .then(function (data) {
                            var raw;
                            if (!(data instanceof ArrayBuffer)) {
                                // JWK
                                raw = liner.string2buffer(JSON.stringify(data));
                            }
                            else {
                                // ArrayBuffer
                                raw = new Uint8Array(data);
                            }
                            return window.crypto.subtle.encrypt(wrapAlgorithm, wrappingKey, raw);
                        })
                            .then(resolve, reject);
                    });
                };
                AesCrypto.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
                    return new Promise(function (resolve, reject) {
                        window.crypto.subtle.decrypt(unwrapAlgorithm, unwrappingKey, wrappedKey)
                            .then(function (data) {
                            var _data;
                            if (format.toLowerCase() === "jwk")
                                _data = JSON.parse(liner.buffer2string(new Uint8Array(data)));
                            else
                                _data = new Uint8Array(data);
                            return window.crypto.subtle.importKey(format, _data, unwrappedKeyAlgorithm, extractable, keyUsages);
                        })
                            .then(resolve, reject);
                    });
                };
                AesCrypto.exportKey = function (format, key) {
                    return new Promise(function (resolve, reject) {
                        var raw = key.key;
                        if (format.toLowerCase() === "jwk") {
                            var jwk = {
                                alg: "A" + key.algorithm.length + /-(\w+)/i.exec(key.algorithm.name.toUpperCase())[1],
                                ext: key.extractable,
                                k: webcrypto.Base64Url.encode(raw),
                                key_ops: key.usages,
                                kty: "oct"
                            };
                            resolve(jwk);
                        }
                        else {
                            resolve(raw.buffer);
                        }
                    });
                };
                AesCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
                    return new Promise(function (resolve, reject) {
                        var raw;
                        if (format.toLowerCase() === "jwk") {
                            var jwk = keyData;
                            raw = webcrypto.Base64Url.decode(jwk.k);
                        }
                        else
                            raw = new Uint8Array(keyData);
                        var key = new liner.CryptoKey();
                        key.algorithm = algorithm;
                        key.type = "secret";
                        key.usages = keyUsages;
                        key.key = raw;
                        resolve(key);
                    });
                };
                return AesCrypto;
            }(webcrypto.BaseCrypto));
            aes.AesCrypto = AesCrypto;
        })(aes = liner.aes || (liner.aes = {}));
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        var rsa;
        (function (rsa) {
            var RsaCrypto = (function (_super) {
                __extends(RsaCrypto, _super);
                function RsaCrypto() {
                    _super.apply(this, arguments);
                }
                RsaCrypto.checkModule = function () {
                    if (typeof asmCrypto === "undefined")
                        throw new liner.LinerError(liner.LinerError.MODULE_NOT_FOUND, "asmCrypto", "https://github.com/vibornoff/asmcrypto.js");
                };
                RsaCrypto.filterUsages = function (supported, given) {
                    return supported.filter(function (item1) { return !!given.filter(function (item2) { return item1 === item2; }).length; });
                };
                RsaCrypto.generateKey = function (alg, extractable, keyUsage) {
                    var _this = this;
                    return new Promise(function (resolve) {
                        _this.checkModule();
                        var pubExp = alg.publicExponent[0] === 3 ? 3 : 65537;
                        var rsaKey = asmCrypto.RSA.generateKey(alg.modulusLength, pubExp);
                        var privateKey = new liner.CryptoKey();
                        var publicKey = new liner.CryptoKey();
                        privateKey.key = publicKey.key = rsaKey;
                        privateKey.algorithm = publicKey.algorithm = alg;
                        privateKey.extractable = publicKey.extractable = extractable;
                        privateKey.type = "private";
                        publicKey.type = "public";
                        switch (alg.name.toLowerCase()) {
                            case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                                privateKey.usages = _this.filterUsages(["decrypt", "unwrapKey"], keyUsage);
                                publicKey.usages = _this.filterUsages(["encrypt", "wrapKey"], keyUsage);
                                break;
                            case webcrypto.AlgorithmNames.RsaPSS.toLowerCase():
                                privateKey.usages = _this.filterUsages(["sign"], keyUsage);
                                publicKey.usages = _this.filterUsages(["verify"], keyUsage);
                                break;
                            default:
                                throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, alg.name);
                        }
                        resolve({ privateKey: privateKey, publicKey: publicKey });
                    });
                };
                RsaCrypto.sign = function (algorithm, key, data) {
                    return new Promise(function (resolve, reject) {
                        switch (algorithm.name.toLowerCase()) {
                            case webcrypto.AlgorithmNames.RsaPSS.toLowerCase():
                                var keyAlg = key.algorithm;
                                var _alg = algorithm;
                                var sign = void 0;
                                switch (keyAlg.hash.name.toUpperCase()) {
                                    case webcrypto.AlgorithmNames.Sha1:
                                        sign = asmCrypto.RSA_PSS_SHA1.sign;
                                        break;
                                    case webcrypto.AlgorithmNames.Sha256:
                                        sign = asmCrypto.RSA_PSS_SHA256.sign;
                                        break;
                                    default:
                                        throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, key.algorithm.name);
                                }
                                resolve(sign(data, key.key, _alg.saltLength / 8).buffer);
                                break;
                            default:
                                throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);
                        }
                    });
                };
                RsaCrypto.verify = function (algorithm, key, signature, data) {
                    return new Promise(function (resolve, reject) {
                        switch (algorithm.name.toLowerCase()) {
                            case webcrypto.AlgorithmNames.RsaPSS.toLowerCase():
                                var keyAlg = key.algorithm;
                                var _alg = algorithm;
                                var verify = void 0;
                                switch (keyAlg.hash.name.toUpperCase()) {
                                    case webcrypto.AlgorithmNames.Sha1:
                                        verify = asmCrypto.RSA_PSS_SHA1.verify;
                                        break;
                                    case webcrypto.AlgorithmNames.Sha256:
                                        verify = asmCrypto.RSA_PSS_SHA256.verify;
                                        break;
                                    default:
                                        throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, key.algorithm.name);
                                }
                                resolve(verify(signature, data, key.key, _alg.saltLength / 8));
                                break;
                            default:
                                throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);
                        }
                    });
                };
                RsaCrypto.encrypt = function (algorithm, key, data) {
                    return new Promise(function (resolve, reject) {
                        switch (algorithm.name.toLowerCase()) {
                            case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                                var keyAlg = key.algorithm;
                                var _alg = algorithm;
                                var encrypt = void 0;
                                switch (keyAlg.hash.name.toUpperCase()) {
                                    case webcrypto.AlgorithmNames.Sha1:
                                        encrypt = asmCrypto.RSA_OAEP_SHA1.encrypt;
                                        break;
                                    case webcrypto.AlgorithmNames.Sha256:
                                        encrypt = asmCrypto.RSA_OAEP_SHA256.encrypt;
                                        break;
                                    default:
                                        throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, keyAlg.name + " " + keyAlg.hash.name);
                                }
                                resolve(encrypt(data, key.key, _alg.label));
                                break;
                            default:
                                throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);
                        }
                    });
                };
                RsaCrypto.decrypt = function (algorithm, key, data) {
                    return new Promise(function (resolve, reject) {
                        switch (algorithm.name.toLowerCase()) {
                            case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                                var keyAlg = key.algorithm;
                                var _alg = algorithm;
                                var decrypt = void 0;
                                switch (keyAlg.hash.name.toUpperCase()) {
                                    case webcrypto.AlgorithmNames.Sha1:
                                        decrypt = asmCrypto.RSA_OAEP_SHA1.decrypt;
                                        break;
                                    case webcrypto.AlgorithmNames.Sha256:
                                        decrypt = asmCrypto.RSA_OAEP_SHA256.decrypt;
                                        break;
                                    default:
                                        throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, keyAlg.name + " " + keyAlg.hash.name);
                                }
                                resolve(decrypt(data, key.key, _alg.label));
                                break;
                            default:
                                throw new liner.LinerError(liner.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);
                        }
                    });
                };
                RsaCrypto.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
                    return new Promise(function (resolve, reject) {
                        window.crypto.subtle.exportKey(format, key)
                            .then(function (data) {
                            var raw;
                            if (!(data instanceof ArrayBuffer)) {
                                // JWK
                                raw = liner.string2buffer(JSON.stringify(data));
                            }
                            else {
                                // ArrayBuffer
                                raw = new Uint8Array(data);
                            }
                            return window.crypto.subtle.encrypt(wrapAlgorithm, wrappingKey, raw);
                        })
                            .then(resolve, reject);
                    });
                };
                RsaCrypto.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
                    return new Promise(function (resolve, reject) {
                        window.crypto.subtle.decrypt(unwrapAlgorithm, unwrappingKey, wrappedKey)
                            .then(function (data) {
                            var _data;
                            if (format.toLowerCase() === "jwk")
                                _data = JSON.parse(liner.buffer2string(new Uint8Array(data)));
                            else
                                _data = new Uint8Array(data);
                            return window.crypto.subtle.importKey(format, _data, unwrappedKeyAlgorithm, extractable, keyUsages);
                        })
                            .then(resolve, reject);
                    });
                };
                RsaCrypto.exportKey = function (format, key) {
                    return new Promise(function (resolve, reject) {
                        if (format.toLowerCase() === "jwk") {
                            var jwk = {
                                kty: "RSA",
                                ext: true,
                                key_ops: key.usages
                            };
                            var hash = key.algorithm.hash;
                            var hashSize = /(\d)+/.exec(hash.name)[1];
                            switch (key.algorithm.name.toUpperCase()) {
                                case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                                    jwk.alg = "RSA-OAEP-" + hashSize;
                                    break;
                                case webcrypto.AlgorithmNames.RsaPSS.toUpperCase():
                                    jwk.alg = "PS" + hashSize;
                                    break;
                                case webcrypto.AlgorithmNames.RsaOAEP.toUpperCase():
                                    jwk.alg = "RS" + hashSize;
                                    break;
                                default:
                                    throw new webcrypto.AlgorithmError(webcrypto.AlgorithmError.UNSUPPORTED_ALGORITHM, key.algorithm.name);
                            }
                            jwk.n = webcrypto.Base64Url.encode(key.key[0]);
                            jwk.e = webcrypto.Base64Url.encode(key.key[1]);
                            if (key.type === "private") {
                                jwk.d = webcrypto.Base64Url.encode(key.key[2]);
                                jwk.p = webcrypto.Base64Url.encode(key.key[3]);
                                jwk.q = webcrypto.Base64Url.encode(key.key[4]);
                                jwk.dp = webcrypto.Base64Url.encode(key.key[5]);
                                jwk.dq = webcrypto.Base64Url.encode(key.key[6]);
                                jwk.qi = webcrypto.Base64Url.encode(key.key[7]);
                            }
                            console.log("Export:", jwk);
                            resolve(jwk);
                        }
                        else {
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED);
                        }
                    });
                };
                RsaCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
                    return new Promise(function (resolve, reject) {
                        var raw;
                        var jwk;
                        var key = new liner.CryptoKey();
                        key.algorithm = algorithm;
                        key.usages = keyUsages;
                        key.key = [];
                        if (format.toLowerCase() === "jwk") {
                            jwk = keyData;
                            key.key[0] = webcrypto.Base64Url.decode(jwk.n);
                            key.key[1] = webcrypto.Base64Url.decode(jwk.e);
                            if (jwk.d) {
                                key.type = "private";
                                key.key[2] = webcrypto.Base64Url.decode(jwk.d);
                                key.key[3] = webcrypto.Base64Url.decode(jwk.p);
                                key.key[4] = webcrypto.Base64Url.decode(jwk.q);
                                key.key[5] = webcrypto.Base64Url.decode(jwk.dp);
                                key.key[6] = webcrypto.Base64Url.decode(jwk.dq);
                                key.key[7] = webcrypto.Base64Url.decode(jwk.qi);
                            }
                            else
                                key.type = "public";
                            resolve(key);
                        }
                        else
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED);
                        resolve(key);
                    });
                };
                return RsaCrypto;
            }(webcrypto.BaseCrypto));
            rsa.RsaCrypto = RsaCrypto;
        })(rsa = liner.rsa || (liner.rsa = {}));
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        var ec;
        (function (ec) {
            // Helper
            function b2a(buffer) {
                var buf = new Uint8Array(buffer);
                var res = [];
                for (var i = 0; i < buf.length; i++)
                    res.push(buf[i]);
                return res;
            }
            function hex2buffer(hexString) {
                var res = new Uint8Array(hexString.length / 2);
                for (var i = 0; i < hexString.length; i++)
                    res[i / 2] = parseInt(hexString.slice(i, ++i), 16);
                return res;
            }
            function buffer2hex(buffer) {
                var res = "";
                for (var i = 0; i < buffer.length; i++) {
                    var char = buffer[i].toString(16);
                    res += char.length % 2 ? char : "0" + char;
                }
                return res;
            }
            var EcCrypto = (function (_super) {
                __extends(EcCrypto, _super);
                function EcCrypto() {
                    _super.apply(this, arguments);
                }
                EcCrypto.checkModule = function () {
                    if (typeof elliptic === "undefined")
                        throw new liner.LinerError(liner.LinerError.MODULE_NOT_FOUND, "elliptic", "https://github.com/indutny/elliptic");
                };
                EcCrypto.generateKey = function (alg, extractable, keyUsage) {
                    var _this = this;
                    return new Promise(function (resolve) {
                        _this.checkModule();
                        var _alg = alg;
                        var key = new elliptic.ec(_alg.namedCurve.replace("-", "").toLowerCase()); // converts name to 'p192', ...
                        // set key params
                        var prvKey = new liner.CryptoKey();
                        var pubKey = new liner.CryptoKey();
                        prvKey.key = pubKey.key = key.genKeyPair();
                        prvKey.algorithm = pubKey.algorithm = _alg;
                        prvKey.extractable = pubKey.extractable = extractable;
                        prvKey.type = "private";
                        pubKey.type = "public";
                        if (alg.name === webcrypto.AlgorithmNames.EcDSA) {
                            prvKey.usages = ["sign"];
                            pubKey.usages = ["verify"];
                        }
                        else if (alg.name === webcrypto.AlgorithmNames.EcDH) {
                            prvKey.usages = pubKey.usages = ["deriveKey", "deriveBits"];
                        }
                        resolve({
                            privateKey: prvKey,
                            publicKey: pubKey
                        });
                    });
                };
                EcCrypto.sign = function (algorithm, key, data) {
                    return new Promise(function (resolve, reject) {
                        var _alg = algorithm;
                        // get digest
                        crypto.subtle.digest(_alg.hash, data)
                            .then(function (hash) {
                            var array = b2a(data);
                            var signature = key.key.sign(array);
                            resolve(new Uint8Array(signature.toDER()).buffer);
                            return Promise.resolve(undefined);
                        })
                            .catch(reject);
                    });
                };
                EcCrypto.verify = function (algorithm, key, signature, data) {
                    return new Promise(function (resolve) {
                        resolve(key.key.verify(data, signature));
                    });
                };
                EcCrypto.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        _this.deriveBits(algorithm, baseKey, derivedKeyType.length)
                            .then(function (bits) {
                            return crypto.subtle.importKey("raw", new Uint8Array(bits), derivedKeyType, extractable, keyUsages);
                        })
                            .then(resolve, reject);
                    });
                };
                EcCrypto.deriveBits = function (algorithm, baseKey, length) {
                    return new Promise(function (resolve, reject) {
                        var promise = Promise.resolve(null);
                        var shared = baseKey.key.derive(algorithm.public.key.getPublic());
                        var buf = new Uint8Array(shared.toArray().slice(0, length / 8)).buffer;
                        resolve(buf);
                    });
                };
                EcCrypto.exportKey = function (format, key) {
                    return new Promise(function (resolve, reject) {
                        var ecKey = key.key;
                        if (format.toLowerCase() === "jwk") {
                            var hexPub = ecKey.getPublic("hex").slice(2); // ignore first '04'
                            var hexX = hexPub.slice(0, hexPub.length / 2);
                            var hexY = hexPub.slice(hexPub.length / 2, hexPub.length);
                            if (key.type === "public") {
                                // public
                                var jwk = {
                                    crv: key.algorithm.namedCurve,
                                    ext: key.extractable,
                                    x: webcrypto.Base64Url.encode(hex2buffer(hexX)),
                                    y: webcrypto.Base64Url.encode(hex2buffer(hexY)),
                                    key_ops: key.usages,
                                    kty: "EC"
                                };
                                resolve(jwk);
                            }
                            else {
                                // private
                                var jwk = {
                                    crv: key.algorithm.namedCurve,
                                    ext: key.extractable,
                                    d: webcrypto.Base64Url.encode(hex2buffer(ecKey.getPrivate("hex"))),
                                    x: webcrypto.Base64Url.encode(hex2buffer(hexX)),
                                    y: webcrypto.Base64Url.encode(hex2buffer(hexY)),
                                    key_ops: key.usages,
                                    kty: "EC"
                                };
                                resolve(jwk);
                            }
                        }
                        else {
                            throw new liner.LinerError("Format '" + format + "' is not implemented");
                        }
                    });
                };
                EcCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
                    return new Promise(function (resolve, reject) {
                        var key = new liner.CryptoKey();
                        key.algorithm = algorithm;
                        if (format.toLowerCase() === "jwk") {
                            var ecKey = new elliptic.ec(keyData.crv.replace("-", "").toLowerCase());
                            if (keyData.d) {
                                // Private key
                                key.key = ecKey.keyFromPrivate(webcrypto.Base64Url.decode(keyData.d));
                                key.type = "private";
                            }
                            else {
                                // Public key
                                key.key = ecKey.keyFromPublic(liner.concat(new Uint8Array([4]), webcrypto.Base64Url.decode(keyData.x), webcrypto.Base64Url.decode(keyData.y)));
                                key.type = "public";
                            }
                        }
                        else
                            throw new liner.LinerError("Format '" + format + "' is not implemented");
                        key.extractable = extractable;
                        key.usages = keyUsages;
                        resolve(key);
                    });
                };
                return EcCrypto;
            }(webcrypto.BaseCrypto));
            ec.EcCrypto = EcCrypto;
        })(ec = liner.ec || (liner.ec = {}));
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        function PrepareKey(key, subtle) {
            var promise = Promise.resolve(key);
            if (!key.key)
                if (!key.extractable) {
                    throw new liner.LinerError("'key' is Native CryptoKey. It can't be converted to JS CryptoKey");
                }
                else {
                    promise = promise.then(function () {
                        return crypto.subtle.exportKey("jwk", key);
                    })
                        .then(function (jwk) {
                        return subtle.importKey("jwk", jwk, key.algorithm, true, key.usages);
                    });
                }
            return promise;
        }
        var SubtleCrypto = (function (_super) {
            __extends(SubtleCrypto, _super);
            function SubtleCrypto() {
                _super.apply(this, arguments);
            }
            SubtleCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {
                var args = arguments;
                var _alg;
                return _super.prototype.generateKey.apply(this, args)
                    .then(function (d) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    try {
                        return liner.nativeSubtle.generateKey.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native generateKey for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native generateKey for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (keys) {
                    if (keys) {
                        if ("keyUsage" in keys || (keys.privateKey && "keyUsage" in keys)) {
                            var _keys = keys;
                            if (!_keys.privateKey)
                                _keys.usages = keyUsages;
                        }
                        return new Promise(function (resolve) { return resolve(keys); });
                    }
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.AesCBC.toLowerCase():
                        case webcrypto.AlgorithmNames.AesGCM.toLowerCase():
                            Class = liner.aes.AesCrypto;
                            break;
                        case webcrypto.AlgorithmNames.EcDSA.toLowerCase():
                        case webcrypto.AlgorithmNames.EcDH.toLowerCase():
                            Class = liner.ec.EcCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                        case webcrypto.AlgorithmNames.RsaPSS.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "generateKey");
                    }
                    return Class.generateKey(_alg, extractable, keyUsages);
                });
            };
            SubtleCrypto.prototype.digest = function (algorithm, data) {
                var args = arguments;
                var _alg;
                var _data;
                return _super.prototype.digest.apply(this, args)
                    .then(function (d) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    _data = webcrypto.PrepareData(data, "data");
                    try {
                        return liner.nativeSubtle.digest.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native digest for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native digest for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (digest) {
                    if (digest)
                        return new Promise(function (resolve) { return resolve(digest); });
                    return liner.sha.ShaCrypto.digest(_alg, _data);
                });
            };
            SubtleCrypto.prototype.sign = function (algorithm, key, data) {
                var args = arguments;
                var _alg;
                var _data;
                return _super.prototype.sign.apply(this, args)
                    .then(function (d) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    _data = webcrypto.PrepareData(data, "data");
                    try {
                        return liner.nativeSubtle.sign.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native sign for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native sign for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (signature) {
                    if (signature)
                        return new Promise(function (resolve) { return resolve(signature); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.EcDSA.toLowerCase():
                            Class = liner.ec.EcCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaPSS.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "sign");
                    }
                    return PrepareKey(key, Class)
                        .then(function (key) { return Class.sign(_alg, key, _data); });
                });
            };
            SubtleCrypto.prototype.verify = function (algorithm, key, signature, data) {
                var args = arguments;
                var _alg;
                var _signature;
                var _data;
                return _super.prototype.verify.apply(this, args)
                    .then(function (d) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    _signature = webcrypto.PrepareData(signature, "data");
                    _data = webcrypto.PrepareData(data, "data");
                    try {
                        return liner.nativeSubtle.verify.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native verify for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native verify for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (result) {
                    if (typeof result === "boolean")
                        return new Promise(function (resolve) { return resolve(signature); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.EcDSA.toLowerCase():
                            Class = liner.ec.EcCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaPSS.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "sign");
                    }
                    return PrepareKey(key, Class)
                        .then(function (key) { return Class.verify(_alg, key, _signature, _data); });
                });
            };
            SubtleCrypto.prototype.deriveBits = function (algorithm, baseKey, length) {
                var args = arguments;
                var _alg;
                return _super.prototype.deriveBits.apply(this, args)
                    .then(function (bits) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    try {
                        return liner.nativeSubtle.deriveBits.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native deriveBits for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        // Edge throws error. Don't know Why.
                        console.warn("WebCrypto: native deriveBits for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (bits) {
                    if (bits)
                        return new Promise(function (resolve) { return resolve(bits); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.EcDH.toLowerCase():
                            Class = liner.ec.EcCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "deriveBits");
                    }
                    return Class.deriveBits(_alg, baseKey, length);
                });
            };
            SubtleCrypto.prototype.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
                var args = arguments;
                var _alg;
                var _algDerivedKey;
                return _super.prototype.deriveKey.apply(this, args)
                    .then(function (bits) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    _algDerivedKey = webcrypto.PrepareAlgorithm(derivedKeyType);
                    try {
                        return liner.nativeSubtle.deriveKey.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native deriveKey for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        // Edge doesn't go to catch of Promise
                        console.warn("WebCrypto: native deriveKey for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (key) {
                    if (key)
                        return new Promise(function (resolve) { return resolve(key); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.EcDH.toLowerCase():
                            Class = liner.ec.EcCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "deriveBits");
                    }
                    return Class.deriveKey(_alg, baseKey, _algDerivedKey, extractable, keyUsages);
                });
            };
            SubtleCrypto.prototype.encrypt = function (algorithm, key, data) {
                var args = arguments;
                var _alg;
                var _data;
                return _super.prototype.encrypt.apply(this, args)
                    .then(function (bits) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    _data = webcrypto.PrepareData(data, "data");
                    try {
                        return liner.nativeSubtle.encrypt.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native 'encrypt' for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native 'encrypt' for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (msg) {
                    if (msg)
                        return new Promise(function (resolve) { return resolve(msg); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.AesCBC.toLowerCase():
                        case webcrypto.AlgorithmNames.AesGCM.toLowerCase():
                            Class = liner.aes.AesCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "encrypt");
                    }
                    return PrepareKey(key, Class)
                        .then(function (key) { return Class.encrypt(_alg, key, _data); });
                });
            };
            SubtleCrypto.prototype.decrypt = function (algorithm, key, data) {
                var args = arguments;
                var _alg;
                var _data;
                return _super.prototype.decrypt.apply(this, args)
                    .then(function (bits) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    _data = webcrypto.PrepareData(data, "data");
                    try {
                        return liner.nativeSubtle.decrypt.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native 'decrypt' for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native 'decrypt' for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (msg) {
                    if (msg)
                        return new Promise(function (resolve) { return resolve(msg); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.AesCBC.toLowerCase():
                        case webcrypto.AlgorithmNames.AesGCM.toLowerCase():
                            Class = liner.aes.AesCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "encrypt");
                    }
                    return PrepareKey(key, Class)
                        .then(function (key) { return Class.decrypt(_alg, key, _data); });
                });
            };
            SubtleCrypto.prototype.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
                var args = arguments;
                var _alg;
                return _super.prototype.wrapKey.apply(this, args)
                    .then(function (bits) {
                    _alg = webcrypto.PrepareAlgorithm(wrapAlgorithm);
                    try {
                        return liner.nativeSubtle.wrapKey.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native 'wrapKey' for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native 'wrapKey' for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (msg) {
                    if (msg)
                        return new Promise(function (resolve) { return resolve(msg); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.AesCBC.toLowerCase():
                        case webcrypto.AlgorithmNames.AesGCM.toLowerCase():
                            Class = liner.aes.AesCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "wrapKey");
                    }
                    return Class.wrapKey(format, key, wrappingKey, _alg);
                });
            };
            SubtleCrypto.prototype.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
                var args = arguments;
                var _alg;
                var _algKey;
                var _data;
                return _super.prototype.unwrapKey.apply(this, args)
                    .then(function (bits) {
                    _alg = webcrypto.PrepareAlgorithm(unwrapAlgorithm);
                    _algKey = webcrypto.PrepareAlgorithm(unwrappedKeyAlgorithm);
                    _data = webcrypto.PrepareData(wrappedKey, "wrappedKey");
                    try {
                        return liner.nativeSubtle.unwrapKey.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native 'unwrapKey' for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native 'unwrapKey' for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (msg) {
                    if (msg)
                        return new Promise(function (resolve) { return resolve(msg); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.AesCBC.toLowerCase():
                        case webcrypto.AlgorithmNames.AesGCM.toLowerCase():
                            Class = liner.aes.AesCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "unwrapKey");
                    }
                    return Class.unwrapKey(format, _data, unwrappingKey, _alg, _algKey, extractable, keyUsages);
                });
            };
            SubtleCrypto.prototype.exportKey = function (format, key) {
                var args = arguments;
                return _super.prototype.exportKey.apply(this, args)
                    .then(function () {
                    try {
                        return liner.nativeSubtle.exportKey.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native 'exportKey' for " + key.algorithm.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native 'exportKey' for " + key.algorithm.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (msg) {
                    if (msg)
                        return Promise.resolve(msg);
                    if (!key.key)
                        throw new liner.LinerError("Cannot export native CryptoKey from JS implementation");
                    var Class;
                    switch (key.algorithm.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.AesCBC.toLowerCase():
                        case webcrypto.AlgorithmNames.AesGCM.toLowerCase():
                            Class = liner.aes.AesCrypto;
                            break;
                        case webcrypto.AlgorithmNames.EcDH.toLowerCase():
                        case webcrypto.AlgorithmNames.EcDSA.toLowerCase():
                            Class = liner.ec.EcCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaPSS.toLowerCase():
                        case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "exportKey");
                    }
                    return Class.exportKey(format, key);
                });
            };
            SubtleCrypto.prototype.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
                var args = arguments;
                var _alg;
                var _data;
                return _super.prototype.importKey.apply(this, args)
                    .then(function (bits) {
                    _alg = webcrypto.PrepareAlgorithm(algorithm);
                    _data = keyData;
                    if (ArrayBuffer.isView(keyData)) {
                        _data = webcrypto.PrepareData(keyData, "keyData");
                    }
                    try {
                        return liner.nativeSubtle.importKey.apply(liner.nativeSubtle, args)
                            .catch(function (e) {
                            console.warn("WebCrypto: native 'importKey' for " + _alg.name + " doesn't work.", e.message || "");
                        });
                    }
                    catch (e) {
                        console.warn("WebCrypto: native 'importKey' for " + _alg.name + " doesn't work.", e.message || "");
                    }
                })
                    .then(function (msg) {
                    if (msg)
                        return new Promise(function (resolve) { return resolve(msg); });
                    var Class;
                    switch (_alg.name.toLowerCase()) {
                        case webcrypto.AlgorithmNames.AesCBC.toLowerCase():
                        case webcrypto.AlgorithmNames.AesGCM.toLowerCase():
                            Class = liner.aes.AesCrypto;
                            break;
                        case webcrypto.AlgorithmNames.EcDH.toLowerCase():
                        case webcrypto.AlgorithmNames.EcDSA.toLowerCase():
                            Class = liner.ec.EcCrypto;
                            break;
                        case webcrypto.AlgorithmNames.RsaPSS.toLowerCase():
                        case webcrypto.AlgorithmNames.RsaOAEP.toLowerCase():
                            Class = liner.rsa.RsaCrypto;
                            break;
                        default:
                            throw new liner.LinerError(liner.LinerError.NOT_SUPPORTED, "importKey");
                    }
                    return Class.importKey(format, _data, _alg, extractable, keyUsages);
                });
            };
            return SubtleCrypto;
        }(webcrypto.SubtleCrypto));
        liner.SubtleCrypto = SubtleCrypto;
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        var LinerError = (function (_super) {
            __extends(LinerError, _super);
            function LinerError() {
                _super.apply(this, arguments);
                this.code = 10;
            }
            LinerError.MODULE_NOT_FOUND = "Module '%1' is not found. Download it from %2.\nOnly hash algorithms supported by the user agent will be supported.";
            LinerError.UNSUPPORTED_ALGORITHM = "Unsupported algorithm '%1'";
            return LinerError;
        }(webcrypto.WebCryptoError));
        liner.LinerError = LinerError;
        var Crypto = (function () {
            function Crypto() {
                this.subtle = new liner.SubtleCrypto();
            }
            Crypto.prototype.getRandomValues = function (array) {
                return liner.nativeCrypto.getRandomValues(array);
            };
            return Crypto;
        }());
        liner.Crypto = Crypto;
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
var webcrypto;
(function (webcrypto) {
    var liner;
    (function (liner) {
        var _w = window;
        liner.browser = liner.BrowserInfo();
        if (_w.msCrypto) {
            if (!_w.Promise)
                throw new liner.LinerError(liner.LinerError.MODULE_NOT_FOUND, "Promise", "https://www.promisejs.org");
            function WrapFunction(subtle, name) {
                var fn = subtle[name];
                subtle[name] = function () {
                    var _args = arguments;
                    return new Promise(function (resolve, reject) {
                        var op = fn.apply(subtle, _args);
                        op.oncomplete = function (e) {
                            console.log("Complited");
                            resolve(e.target.result);
                        };
                        op.onerror = function (e) {
                            console.log("Error");
                            reject("Error on running '" + name + "' function");
                        };
                    });
                };
            }
            WrapFunction(liner.nativeSubtle, "generateKey");
            WrapFunction(liner.nativeSubtle, "digest");
            WrapFunction(liner.nativeSubtle, "sign");
            WrapFunction(liner.nativeSubtle, "verify");
            WrapFunction(liner.nativeSubtle, "encrypt");
            WrapFunction(liner.nativeSubtle, "decrypt");
            WrapFunction(liner.nativeSubtle, "importKey");
            WrapFunction(liner.nativeSubtle, "exportKey");
            WrapFunction(liner.nativeSubtle, "wrapKey");
            WrapFunction(liner.nativeSubtle, "unwrapKey");
            WrapFunction(liner.nativeSubtle, "deriveKey");
            WrapFunction(liner.nativeSubtle, "deriveBits");
        }
        delete window.crypto;
        _w.crypto = new liner.Crypto();
    })(liner = webcrypto.liner || (webcrypto.liner = {}));
})(webcrypto || (webcrypto = {}));
